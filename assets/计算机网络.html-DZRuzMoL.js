import{_ as t,r as a,o,c as s,a as l,b as i,d as n,e as p}from"./app-Bn7XLESk.js";const c="/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png",P="/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png",T="/imgs/CDN.webp",r="/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%BA%94%E7%B1%BBIP%E5%9C%B0%E5%9D%80.png",h="/imgs/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%90%84%E7%B1%BBIP%E5%9C%B0%E5%9D%80%E7%9A%84%E8%8C%83%E5%9B%B4.png",C={},d=p('<h1 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络"><span>计算机网络</span></a></h1><h2 id="udp-和-tcp" tabindex="-1"><a class="header-anchor" href="#udp-和-tcp"><span>UDP 和 TCP</span></a></h2><h3 id="udp" tabindex="-1"><a class="header-anchor" href="#udp"><span>UDP</span></a></h3><p>UDP，用户数据报协议，是网络五层模型传输层上面的协议。</p><ol><li>UDP 是一个面向报文的协议。意思就是 UDP 只是对报文进行搬运，不会对报文进行才分和拼接操作。</li><li>UDP 不可靠，无连接，它接收到什么数据就返回什么数据，不会对数据进行备份，也不会关心对方能不能接收到数据。</li><li>UDP 高效：因为 UDP 没有 TCP 那么复杂，头部开销很小，相比 TCP 至少 20 个字节要少得多。</li><li>UDP 支持一对一、多对多、多对一的传输方式。</li><li>应用场景：在某些实时性要求较高的场景，如电话会议、视频直播等。</li></ol><h3 id="tcp" tabindex="-1"><a class="header-anchor" href="#tcp"><span>TCP</span></a></h3><p>TCP 传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议</p><ol><li>面向连接：TCP 的连接过程一共有以下三步，三次握手、传输数据、四次挥手</li><li>TCP 的可靠性：通过将数据分成报文段、超时重传机制、首部和数据的校验和保证数据的可靠性。</li><li>TCP 只支持一对一的传输方式</li><li>因为 TCP 头部至少是会有 20 个字节的数据，还要在发送请求之前进行三次握手，所以它的传输效率是相比 UDP 来说是比较低的。</li></ol><h3 id="tcp-三次握手" tabindex="-1"><a class="header-anchor" href="#tcp-三次握手"><span>TCP 三次握手</span></a></h3><p>为了保证客户端和服务器端的可靠连接，TCP 建立连接时必须要进行三次会话，也叫 TCP 三次握手，<span style="color:red;">进行三次握手的目的是为了确认双方的接收能力和发送能力是否正常</span>。</p><p><img src="'+c+'" alt="TCP三次握手"></p><ol><li><p>最开始的时候客户端和服务器都是处于 CLOSED 关闭状态。主动打开连接的为客户端，被动打开连接的是服务器。</p></li><li><p>TCP 服务器进程先创建传输控制块 TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了 <strong>LISTEN 监听状态</strong></p></li><li><p>第一次握手 TCP 客户进程也是先创建传输控制块 TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位 SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP 客户端进程进入了 <strong>SYN-SENT 同步已发送状态</strong></p></li><li><p>第二次握手 TCP 服务器收到请求报文后，如果同意连接，则会向客户端发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是 ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP 服务器进程进入了 <strong>SYN-RCVD 同步收到状态</strong></p></li><li><p>第三次握手 TCP 客户端收到确认后，还要向服务器给出确认。确认报文的 ACK=1，ack=y+1，自己的序列号 seq=x+1，此时，TCP 连接建立，客户端进入 <strong>ESTABLISHED(已获确认的)</strong> 已建立连接状态 触发三次握手</p></li></ol><p>有人可能会很疑惑为什么要进行第三次握手？ 主要原因：防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误</p><ul><li>第一次握手： 客户端向服务器端发送报文 证明客户端的发送能力正常</li><li>第二次握手：服务器端接收到报文并向客户端发送报文 证明服务器端的接收能力、发送能力正常</li><li>第三次握手：客户端向服务器发送报文 证明客户端的接收能力正常</li></ul><p>如果采用两次握手会出现以下情况：</p><blockquote><p>客户端向服务器端发送的请求报文由于网络等原因滞留，未能发送到服务器端，此时连接请求报文失效，客户端会再次向服务器端发送请求报文，之后与服务器端建立连接，当连接释放后，由于网络通畅了，第一次客户端发送的请求报文又突然到达了服务器端，这条请求报文本该失效了，但此时服务器端误认为客户端又发送了一次连接请求，两次握手建立好连接，此时客户端忽略服务器端发来的确认，也不发送数据，造成不必要的错误和网络资源的浪费。</p><p>如果采用三次握手的话，就算那条失效的报文发送到服务器端，服务器端确认并向客户端发送报文，但此时客户端不会发出确认，由于客户端没有确认，由于服务器端没有接收到确认，就会知道客户端没有请求连接。</p></blockquote><h3 id="tcp四次挥手" tabindex="-1"><a class="header-anchor" href="#tcp四次挥手"><span>TCP四次挥手</span></a></h3><p><img src="'+P+'" alt="TCP四次挥手"></p><ol><li><p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。</p></li><li><p>第一次挥手 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态</p></li><li><p>第二次挥手 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT 关闭等待状态</p></li><li><p>第三次挥手 客户端接收到服务器端的确认请求后，客户端就会进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</p></li><li><p>第四次挥手 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态，但此时TCP连接还未终止，必须要经过2MSL后（最长报文寿命），当客户端撤销相应的TCB后，客户端才会进入CLOSED关闭状态，服务器端接收到确认报文后，会立即进入CLOSED关闭状态，到这里TCP连接就断开了，四次挥手完成</p></li></ol><p><strong>为什么客户端要等待2MSL？</strong></p><p>主要原因是为了保证客户端发送那个的第一个ACK报文能到到服务器，因为这个ACK报文可能丢失，并且2MSL是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，这样新的连接中不会出现旧连接的请求报文。</p><h2 id="http-https" tabindex="-1"><a class="header-anchor" href="#http-https"><span>HTTP/HTTPS</span></a></h2>',22),u={href:"https://www.runoob.com/http/http-tutorial.html",target:"_blank",rel:"noopener noreferrer"},E=p('<ol><li>客户端向服务器发送请求报文，服务端就需要向客户端回送响应报文，http 规定了请求响应的报文格式。</li><li>请求报文格式：请求行的请求方法、请求 URL、http 版本；请求头部、空行和请求体</li><li>响应报文格式：状态行的协议版本、状态码和描述状态；响应头部、空行和响应体</li><li>HTTP 是基于传输层 TCP 协议的，需要 TCP 三次握手后建立可靠连接才能进行应用层的通信。</li><li>HTTP 是一种无状态 (stateless) 协议, HTTP 协议本身不会对发送过的请求和相应的通信状态进行持久化处理。这样做的目的是为了保持 HTTP 协议的简单性，从而能够快速处理大量的事务, 提高效率。</li><li>HTTPS：HTTP 协议中没有加密机制,但可以通 过和 SSL(Secure Socket Layer, 安全套接层 )或 TLS(Transport Layer Security, 安全层传输协议)的组合使用,加密 HTTP 的通信内容。属于通信加密，即在整个通信线路中加密。</li><li>HTTPS 采用共享密钥加密（对称）和公开密钥加密（非对称）两者并用的混合加密机制。</li></ol><h4 id="http-与-https-区别" tabindex="-1"><a class="header-anchor" href="#http-与-https-区别"><span>HTTP 与 HTTPS 区别</span></a></h4><p>加密：</p><blockquote><ul><li>HTTP：数据传输过程中不加密，容易被截获和篡改。</li><li>HTTPS：使用 SSL/TLS 协议对传输的数据进行加密，保护数据传输过程中的安全性。</li></ul></blockquote><p>端口</p><blockquote><ul><li>HTTP：默认使用端口 80。</li><li>HTTPS：默认使用端口 443。</li></ul></blockquote><p>安全性：</p><blockquote><ul><li>HTTP：不提供数据加密，安全性较低。</li><li>HTTPS：提供数据加密和完整性校验，安全性较高。</li></ul></blockquote><p>证书：</p><blockquote><ul><li>HTTP：不需要证书。</li><li>HTTPS：需要 SSL 证书来启用加密，并验证服务器的身份。</li></ul></blockquote><p>性能：</p><blockquote><ul><li>HTTP：由于不加密数据，性能略高于 HTTPS。</li><li>HTTPS：由于需要进行加密和解密，可能会有一定的性能开销。</li></ul></blockquote><p>搜索引擎优化(SEO)：</p><blockquote><ul><li>HTTP：搜索引擎可能会对没有使用 HTTPS 的网站进行降权。</li><li>HTTPS：搜索引擎倾向于优先索引和展示使用 HTTPS 的网站。</li></ul></blockquote><p>浏览器显示</p><blockquote><ul><li>HTTP：在大多数现代浏览器中，HTTP 网站通常显示为&quot;不安全&quot;。</li><li>HTTPS：浏览器会显示一个锁形图标，表示网站是安全的。</li></ul></blockquote><p>成本：</p><blockquote><ul><li>HTTP：通常免费。</li><li>HTTPS：需要购买 SSL 证书，可能会有一定的成本。</li></ul></blockquote><p>应用场景：</p><blockquote><ul><li>HTTP：适用于不需要传输敏感信息的网站，如新闻网站、博客等。</li><li>HTTPS：适用于需要传输敏感信息的网站，如网上银行、在线购物、电子邮件等。</li></ul></blockquote><h2 id="cdn" tabindex="-1"><a class="header-anchor" href="#cdn"><span>CDN</span></a></h2><p>CDN 就是采用更多的缓存服务器（CDN 边缘节点），布放在用户访问相对集中的地区或网络中。当用户访问网站时，利用全局负载技术，将用户的访问指向距离最近的缓存服务器上，由缓存服务器响应用户请求。</p><h4 id="cdn-的步骤" tabindex="-1"><a class="header-anchor" href="#cdn-的步骤"><span>CDN 的步骤</span></a></h4><p>具体步骤： <br>①、当用户点击 APP 上的内容，APP 会根据 URL 地址去本地 DNS（域名解析系统）寻求 IP 地址解析。 <br>②、本地 DNS 系统会将域名的解析权交给 CDN 专用 DNS 服务器。 <br>③、CDN 专用 DNS 服务器，将 CDN 的全局负载均衡设备 IP 地址返回用户。 <br>④、用户向 CDN 的负载均衡设备发起内容 URL 访问请求。 <br>⑤、CDN 负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的缓存服务器。 <br>⑥、负载均衡设备告诉用户这台缓存服务器的 IP 地址，让用户向所选择的缓存服务器发起请求。 <br>⑦、用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。 <br>⑧、如果这台缓存服务器上并没有用户想要的内容，那么这台缓存服务器就要网站的源服务器请求内容。 <br>⑨、源服务器返回内容给缓存服务器，缓存服务器发给用户，并根据用户自定义的缓存策略，判断要不要把内容缓存到缓存服务器上。</p><p><img src="'+T+'" alt="CDN.webp"></p><h4 id="cdn-的好处" tabindex="-1"><a class="header-anchor" href="#cdn-的好处"><span>CDN 的好处</span></a></h4><ol><li>就是加速了网站的访问——用户与内容之间的物理距离缩短，用户的等待时间也得以缩短。</li><li>CDN 还有安全方面的好处。内容进行分发后，源服务器的 IP 被隐藏，受到攻击的概率会大幅下降。而且，当某个服务器故障时，系统会调用临近的健康服务器，进行服务，避免对用户造成影响。</li></ol><h2 id="ipv4-和-ipv6" tabindex="-1"><a class="header-anchor" href="#ipv4-和-ipv6"><span>IPV4 和 IPV6</span></a></h2><ol><li>IPV4 是 32 位长度的（转为 10 进制，点分十进制表示），IPV6 是 128 位长度的（转化为 16 进制的，用冒号：进行分割，根据 0 的特点还能进行简写）。</li><li>IPV4 和 IPV6 的首部，首先都有版本、源地址和目的地址，IPV6 虽然在 IPV4 的基础上进行改进，但其首部要比 IPV4 少得多。</li><li>IPV4 可以基于子网掩码进行 CIDR，但是 IPV6 没有子网掩码。</li><li>IPV6 并没有像 IPV4 那样分 ABCD 类地址了，分全球单播地址(公有地址)、链路本地地址（fe80:开头），回环地址(::1/128)、未指明地址（::/128）</li><li>虽然 IPV6 在设计的时候考虑了很多的安全问题，但是目前用的并不是很广泛，也不能确定 IPV4 和 IPV6 哪个更安全。</li></ol><h2 id="ip-地址分类" tabindex="-1"><a class="header-anchor" href="#ip-地址分类"><span>IP 地址分类</span></a></h2><p>IP 地址由四段组成，每个字段是一个字节，8 位，最大值是 255，,</p><p>IP 地址由两部分组成，即网络地址和主机地址。网络地址表示其属于互联网的哪一个网络，主机地址表示其属于该网络中的哪一台主机。二者是主从关系。</p><p>IP 地址的四大类型标识的是网络中的某台主机。IPv4 的地址长度为 32 位，共 4 个字节，但实际中我们用点分十进制记法。</p><p><img src="'+r+'" alt=""></p><p>IP 地址根据网络号和主机号来分，分为 A、B、C 三类及特殊地址 D、E。 全 0 和全 1 的都保留不用。</p><p>A 类：(1.0.0.0-126.0.0.0)（默认子网掩码：255.0.0.0 或 0xFF000000）第一个字节为网络号，后三个字节为主机号。该类 IP 地址的最前面为“0”，所以地址的网络号取值于 1~126 之间。一般用于大型网络。</p><p>B 类：(128.0.0.0-191.255.0.0)（默认子网掩码：255.255.0.0 或 0xFFFF0000）前两个字节为网络号，后两个字节为主机号。该类 IP 地址的最前面为“10”，所以地址的网络号取值于 128~191 之间。一般用于中等规模网络。</p><p>C 类：(192.0.0.0-223.255.255.0)（子网掩码：255.255.255.0 或 0xFFFFFF00）前三个字节为网络号，最后一个字节为主机号。该类 IP 地址的最前面为“110”，所以地址的网络号取值于 192~223 之间。一般用于小型网络。</p><p>D 类：是多播地址。该类 IP 地址的最前面为“1110”，所以地址的网络号取值于 224~239 之间。一般用于多路广播用户[1] 。</p><p>E 类：是保留地址。该类 IP 地址的最前面为“1111”，所以地址的网络号取值于 240~255 之间。</p><p>在 IP 地址 3 种主要类型里，各保留了 3 个区域作为私有地址，其地址范围如下：</p><ul><li>A 类地址：10.0.0.0 ～ 10.255.255.255</li><li>B 类地址：172.16.0.0 ～ 172.31.255.255</li><li>C 类地址：192.168.0.0 ～ 192.168.255.255</li></ul><p>回送地址：127.0.0.1。 也是本机地址，等效于 localhost 或本机 IP。一般用于测试使用。例如：ping 127.0.0.1 来测试本机 TCP/IP 是否正常。</p><p><img src="'+h+'" alt=""></p>',44);function S(I,b){const e=a("ExternalLinkIcon");return o(),s("div",null,[d,l("p",null,[l("a",u,[i("菜鸟网站 HTTP"),n(e)]),i("是应用层维持客户端和服务端进行网络通信的协议")]),E])}const B=t(C,[["render",S],["__file","计算机网络.html.vue"]]),D=JSON.parse('{"path":"/computer/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html","title":"计算机网络","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"UDP 和 TCP","slug":"udp-和-tcp","link":"#udp-和-tcp","children":[{"level":3,"title":"UDP","slug":"udp","link":"#udp","children":[]},{"level":3,"title":"TCP","slug":"tcp","link":"#tcp","children":[]},{"level":3,"title":"TCP 三次握手","slug":"tcp-三次握手","link":"#tcp-三次握手","children":[]},{"level":3,"title":"TCP四次挥手","slug":"tcp四次挥手","link":"#tcp四次挥手","children":[]}]},{"level":2,"title":"HTTP/HTTPS","slug":"http-https","link":"#http-https","children":[]},{"level":2,"title":"CDN","slug":"cdn","link":"#cdn","children":[]},{"level":2,"title":"IPV4 和 IPV6","slug":"ipv4-和-ipv6","link":"#ipv4-和-ipv6","children":[]},{"level":2,"title":"IP 地址分类","slug":"ip-地址分类","link":"#ip-地址分类","children":[]}],"filePathRelative":"computer/计算机网络.md","git":{"createdTime":1715780535000,"updatedTime":1728309614000,"contributors":[{"name":"xiaoyu","email":"luoyu2003@outlook.com","commits":6}]},"readingTime":{"minutes":12.73,"words":3820}}');export{B as comp,D as data};
