import{_ as a,r as o,o as l,c as i,a as e,b as d,d as r,e as c}from"./app-Bn7XLESk.js";const s="/imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png",n="/imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/%E8%BF%94%E5%9B%9E304.png",p="/imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/%E8%BF%94%E5%9B%9E200.png",h="/imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/Last-Modified.png",g="/imgs/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/ETag.png",x={},E=e("h1",{id:"浏览器缓存",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#浏览器缓存"},[e("span",null,"浏览器缓存")])],-1),m=e("strong",null,"参考文章",-1),f=e("br",null,null,-1),u={href:"https://juejin.cn/post/6844903764566999054#heading-27",target:"_blank",rel:"noopener noreferrer"},C=c('<h2 id="浏览器缓存的这些策略的应用场景" tabindex="-1"><a class="header-anchor" href="#浏览器缓存的这些策略的应用场景"><span>浏览器缓存的这些策略的应用场景</span></a></h2><h3 id="实际场景应用缓存策略" tabindex="-1"><a class="header-anchor" href="#实际场景应用缓存策略"><span>实际场景应用缓存策略</span></a></h3><ol><li>频繁变动的资源</li></ol><p><code>Cache-Control: no-cache</code></p><p>对于频繁变动的资源，首先需要使用 <code>Cache-Control:no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code> 或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p><ol start="2"><li>不常变化的资源</li></ol><p><code>Cache-Control: max-age=31536000</code></p><p>通常在处理这类资源时，给它们的 <code>Cache-Control</code> 配置一个很大的 <code>max-age=31536000</code> (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。<br></p><blockquote><p>而为了解决更新的问题，就需要在文件名(或者路径)中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (<code>其实并未立即失效，只是不再使用了而已</code>)。在线提供的类库 (如 jquery-3.3.1.min.js, lodash.min.js 等) 均采用这个模式。</p></blockquote><h3 id="用户行为对浏览器缓存的影响" tabindex="-1"><a class="header-anchor" href="#用户行为对浏览器缓存的影响"><span>用户行为对浏览器缓存的影响</span></a></h3><p>所谓用户行为对浏览器缓存的影响，指的就是用户在浏览器如何操作时，会触发怎样的缓存策略。主要有 3 种：</p><ul><li>打开网页，地址栏输入地址：查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control:no-cache(为了兼容，还带了 Pragma:no-cache),服务器直接返回 200 和最新内容。</li></ul><h2 id="强缓存" tabindex="-1"><a class="header-anchor" href="#强缓存"><span>强缓存</span></a></h2><p>强缓存：不会向服务器发送请求，直接从缓存中读取资源，在 chrome 控制台的 Network 选项中可以看到该请求返回 200 的状态码，并且 Size 显示 from disk cache 或 from memory cache。强缓存可以通过设置两种 <code>HTTP Header</code> 实现：<code>Expires</code> 和 <code>Cache-Control</code>。</p><ol><li>Expires</li></ol><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间。Expires 是 Web 服务器响应消息头字段，在响应 http 请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p>Expires 是 HTTP/1.0 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><blockquote><p>Expires:Wed,22Oct201808:41:00GMT 表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。</p></blockquote><ol start="2"><li>Cache-Control</li></ol><p>在 HTTP/1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存。比如当 Cache-Control:max-age=300 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的 5 分钟内再次加载资源，就会命中强缓存。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p><table><thead><tr><th style="text-align:center;">指令</th><th style="text-align:center;">作用</th></tr></thead><tbody><tr><td style="text-align:center;">public</td><td style="text-align:center;">表示响应可以被客户端和代理服务器缓存</td></tr><tr><td style="text-align:center;">private</td><td style="text-align:center;">表示响应只可以被客户端缓存</td></tr><tr><td style="text-align:center;">max-age-30</td><td style="text-align:center;">缓存30秒后就过期，需要重新请求</td></tr><tr><td style="text-align:center;">s-maxage-30</td><td style="text-align:center;">覆盖max-age，作用一样，只在代理服务器中生效</td></tr><tr><td style="text-align:center;">no-store</td><td style="text-align:center;">不缓存任何响应</td></tr><tr><td style="text-align:center;">no-cache</td><td style="text-align:center;">资源被缓存，但是立即失效，下次会发起请求验证资源是否过期</td></tr><tr><td style="text-align:center;">max-stale 30</td><td style="text-align:center;">30秒内，即使缓存过期，也使用该缓存</td></tr><tr><td style="text-align:center;">min-fresh=30</td><td style="text-align:center;">希望在30秒内获取最新的响应</td></tr></tbody></table><blockquote><ul><li><code>public</code>：所有内容都将被缓存（客户端和代理服务器都可缓存）。具体来说响应可被任何中间节点缓存，如 Browser &lt;-- proxy1 &lt;-- proxy2 &lt;-- Server，中间的 proxy 可以缓存资源，比如下次再请求同一资源 proxy1 直接把自己缓存的东西给 Browser 而不再向 proxy2 要。</li><li><code>private</code>：所有内容只有客户端可以缓存，Cache-Control 的默认取值。具体来说，表示中间节点不允许缓存，对于 Browser &lt;-- proxy1 &lt;-- proxy2 &lt;-- Server，proxy 会老老实实把 Server 返回的数据发送给 proxy1,自己不缓存任何数据。当下次 Browser 再次请求时 proxy 会做好请求转发而不是自作主张给自己缓存的数据。</li><li><code>no-cache</code>：客户端缓存内容，<code>是否使用缓存则需要经过协商缓存来验证决定。表示不使用 Cache-Control 的缓存控制方式做前置验证，而是使用 Etag 或者 Last-Modified 字段来控制缓存</code>。需要注意的是，no-cache 这个名字有一点误导。设置了 no-cache 之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</li><li><code>no-store</code>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li><code>max-age</code>：max-age=xxx (xxx is numeric)表示缓存内容将在 xxx 秒后失效</li><li><code>s-maxage(单位为 s)</code>：同 max-age 作用一样，只在代理服务器中生效（比如 CDN 缓存）。比如当 s-maxage=60 时，在这 60 秒中，即使更新了 CDN 的内容，浏览器也不会进行请求。max-age 用于普通缓存，而 s-maxage 用于代理缓存。s-maxage 的优先级高于 max-age。如果存在 s-maxage，则会覆盖掉 max-age 和 Expires header。</li><li><code>max-stale</code>：能容忍的最大过期时间。max-stale 指令标示了客户端愿意接收一个已经过期了的响应。如果指定了 max-stale 的值，则最大容忍时间为对应的秒数。如果没有指定，那么说明浏览器愿意接收任何 age 的响应（age 表示响应由源站生成或确认的时间与当前时间的差值）。</li><li><code>min-fresh</code>：能够容忍的最小新鲜度。min-fresh 标示了客户端不愿意接受新鲜度不多于当前的 age 加上 min-fresh 设定的时间之和的响应。</li></ul></blockquote><p><img src="'+s+'" alt=".png"> 从图中我们可以看到，我们可以将多个指令配合起来一起使用，达到多个目的。比如说我们希望资源能被缓存下来，并且是客户端和代理服务器都能缓存，还能设置缓存失效时间等等。</p><ol start="3"><li>Expires 和 Cache-Control 两者对比</li></ol><p>其实这两者差别不大，区别就在于 Expires 是 http1.0 的产物，Cache-Control 是 http1.1 的产物，两者同时存在的话，Cache-Control 优先级高于 Expires；在某些不支持 HTTP1.1 的环境下，Expires 就会发挥用处。所以 Expires 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。<code>强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容</code>，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。</p><h2 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存"><span>协商缓存</span></a></h2><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：</p><ul><li><p>协商缓存生效，返回 304 和 Not Modified <img src="'+n+'" alt="304.png"></p></li><li><p>协商缓存失效，返回 200 和请求结果 <img src="'+p+`" alt="200.png"></p></li></ul><p>协商缓存可以通过设置两种 HTTP Header 实现：<code>Last-Modified</code> 和 <code>ETag</code> 。</p><ol><li>Last-Modified 和 If-Modified-Since</li></ol><p>浏览器在第一次访问资源时，服务器返回资源的同时，在 response header 中添加 Last-Modified 的 header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和 header；</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="language-text"><code>Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>浏览器下一次请求这个资源，浏览器检测到有 Last-Modified 这个 header，于是添加 If-Modified-Since 这个 header，值就是 Last-Modified 中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回 304 和空的响应体，直接从缓存读取，如果 If-Modified-Since 的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和 200</p><p><img src="`+h+'" alt="Last-Modified.png"></p><p><strong>但是 Last-Modified 存在一些弊端：</strong></p><ul><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源</li><li>因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li></ul><p>既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略？所以在 HTTP / 1.1 出现了 ETag 和 If-None-Match</p><ol start="2"><li>ETag 和 If-None-Match</li></ol><p>Etag 是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag 就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的 Etag 值放到 request header 里的 If-None-Match 里，服务器只需要比较客户端传来的 If-None-Match 跟自己服务器上该资源的 ETag 是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现 ETag 匹配不上，那么直接以常规 GET 200 回包形式将新的资源（当然也包括了新的 ETag）发给客户端；如果 ETag 是一致的，则直接返回 304 知会客户端直接使用本地缓存即可。</p><blockquote><p>ETag生成结论(面试官问过的！)</p><ol><li>对于静态文件（如css、js、图片等），ETag的生成策略是：文件大小的16进制+修改时间</li><li>对于字符串或Buffer，ETag的生成策略是：字符串/Buffer长度的16进制+对应的hash值</li></ol></blockquote><p><img src="'+g+'" alt="ETag.png"></p><ol start="3"><li>两者之间对比：</li></ol><ul><li>首先在精确度上，Etag 要优于 Last-Modified。</li></ul><blockquote><p>Last-Modified 的时间单位是秒，如果某个文件在 1 秒内改变了多次，那么他们的 Last-Modified 其实并没有体现出来修改，但是 Etag 每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的 Last-Modified 也有可能不一致。</p></blockquote><ul><li>第二在性能上，Etag 要逊于 Last-Modified，毕竟 Last-Modified 只需要记录时间，而 Etag 需要服务器通过算法来计算出一个 hash 值。</li><li>第三在优先级上，服务器校验优先考虑 Etag</li></ul>',46);function _(y,T){const t=o("ExternalLinkIcon");return l(),i("div",null,[E,e("p",null,[m,f,e("a",u,[d("掘金作者 实践这一次,彻底搞懂浏览器缓存机制"),r(t)])]),C])}const M=a(x,[["render",_],["__file","浏览器缓存.html.vue"]]),B=JSON.parse('{"path":"/advance/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.html","title":"浏览器缓存","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"浏览器缓存的这些策略的应用场景","slug":"浏览器缓存的这些策略的应用场景","link":"#浏览器缓存的这些策略的应用场景","children":[{"level":3,"title":"实际场景应用缓存策略","slug":"实际场景应用缓存策略","link":"#实际场景应用缓存策略","children":[]},{"level":3,"title":"用户行为对浏览器缓存的影响","slug":"用户行为对浏览器缓存的影响","link":"#用户行为对浏览器缓存的影响","children":[]}]},{"level":2,"title":"强缓存","slug":"强缓存","link":"#强缓存","children":[]},{"level":2,"title":"协商缓存","slug":"协商缓存","link":"#协商缓存","children":[]}],"filePathRelative":"advance/浏览器缓存.md","git":{"createdTime":1716724118000,"updatedTime":1717914125000,"contributors":[{"name":"xiaoyu","email":"luoyu2003@outlook.com","commits":2}]},"readingTime":{"minutes":9.65,"words":2895}}');export{M as comp,B as data};
