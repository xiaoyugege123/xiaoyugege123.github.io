import{_ as l,r as s,o as p,c as a,a as t,b as r,d as n,e as o}from"./app-Bn7XLESk.js";const i={},g=o(`<h1 id="其他的一些小问题" tabindex="-1"><a class="header-anchor" href="#其他的一些小问题"><span>其他的一些小问题</span></a></h1><h2 id="proxy的优缺点" tabindex="-1"><a class="header-anchor" href="#proxy的优缺点"><span>proxy的优缺点？</span></a></h2><p><strong>Object.defineProperty的缺陷:</strong></p><ol><li><p><strong>无法检测到对象属性的新增或删除</strong></p><p>由于js的动态性，可以为对象追加新的属性或者删除其中某个属性， 这点对经过Object.defineProperty方法建立的响应式对象来说，只能追踪对象已有数据是否被修改，无法追踪新增属性和删除属性，这就需要另外处理。</p></li><li><p><strong>不能监听数组的变化（对数组基于下标的修改、对于 .length 修改的监测）</strong></p><p>vue在实现数组的响应式时，它使用了一些hack，把无法监听数组的情况通过重写数组的部分方法来实现响式，这也只限制在数组的push/pop/shift/unshift/splice/sort/reverse七个方法，其他数组方法及数组的使用则无法检测到， 解决方法主要是使用proxy属性,这个proxy属性是ES6中新增的一个属性,proxy属性也是一个构造函数,他也可以通过new的方式创建这个函数,表示修改某些操作的默认行为,等同于在语言层面做出修改,所以属于一种元编程proxy可以理解为在目标对象之前架设一层拦截,外界对该对象的访问,都必须经过这层拦截,因此提出了一种机制,可以对外界的网文进行过滤和改写,proxy这个词是代理,用来表示由他代理某些操作,可以译为代理器</p></li></ol><p><strong>proxy代理的特点:</strong></p><ul><li>proxy直接代理的是整个对象而非对象属性</li><li>proxy的代理针对的是整个对象而不是像object.defineProperty针对某个属性</li><li>只需要做一层代理就可以监听同级结构下的所有属性变化，包括新增的属性和删除的属性</li><li>proxy代理身上定义的方法共有13种,其中我们最常用的就是set和get,但是他本身还有其他的13种方法</li></ul><p><strong>proxy的劣势:</strong></p><p>兼容性问题,虽然proxy相对越object.defineProperty有很有优势,但是并不是说proxy,就是完全的没有劣势,主要表现在以下的两个方面:</p><ol><li><p>proxy有兼容性问题,无完全的polyfill: proxy为ES6新出的API,浏览器对其的支持情况可在w3c规范中查到,通过查找我们可以知道, 虽然大部分浏览器支持proxy特性,但是一些浏览器或者低版本不支持proxy, 因此proxy有兼容性问题,那能否像ES6其他特性有polyfill解决方案呢?, 这时我们通过查询babel文档,发现在使用babel对代码进行降级处理的时候,并没有合适的polyfill</p></li><li><p>第二个问题就是性能问题,proxy的性能其实比promise还差, 这就需要在性能和简单实用上进行权衡,例如vue3使用proxy后, 其对对象及数组的拦截很容易实现数据的响应式,尤其是数组</p><pre><code> 虽然proxy有性能和兼容性处理,但是proxy作为新标准将受到浏览器厂商重点持续的性能优化,
 性能这块会逐步得到改善
</code></pre></li></ol>`,9),d={href:"https://juejin.cn/post/6844903601416978439",target:"_blank",rel:"noopener noreferrer"},c=t("h2",{id:"vue的双向绑定原理-腾讯",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#vue的双向绑定原理-腾讯"},[t("span",null,"Vue的双向绑定原理（腾讯）")])],-1),h={href:"https://juejin.cn/post/7080562890628923423#heading-29",target:"_blank",rel:"noopener noreferrer"},u={href:"https://zhuanlan.zhihu.com/p/138710460",target:"_blank",rel:"noopener noreferrer"},x=o('<h2 id="http请求方法-幂等和非幂等" tabindex="-1"><a class="header-anchor" href="#http请求方法-幂等和非幂等"><span>HTTP请求方法：幂等和非幂等？</span></a></h2><p><strong>幂等性和安全性是http请求方法的特性, 比如 get请求方法是具有安全的</strong></p><p><strong>安全性(此次请求不会修改后台):</strong></p><blockquote><p>** 仅指该方法的多次调用不会产生副作用，不涉及传统意义上的“安全”，这里的副作用是指资源状态。** <strong>即，安全的方法不会修改资源状态，尽管多次调用的返回值可能不一样(被其他非安全方法修改过)。</strong></p></blockquote><hr><p><strong>幂等性(多次请求一个url,返回值不变):</strong></p><blockquote><p>** 是指该方法多次调用返回的效果(形式)一致，客户端可以重复调用并且期望同样的结果。一次调用和多次调用产生的效果是一致的，都是对一个变量进行赋值。**</p></blockquote><p><strong>————————————————————————————————</strong><strong>方法名 安全性 幂等性 请求方法的作用</strong><strong>get √ √ 请求指定的页面信息，并返回实体主体</strong><strong>head √ √ 只请求页面的首部</strong><strong>options √ √ 允许客户端查看服务器的性能</strong><strong>delete × √ 请求服务器删除指定的数据</strong><strong>put × √ 从客户端向服务器传送的数据取代指定的文档的内容</strong><strong>post × × 请求服务器接受所指定的文档作为对所标识的URI的新的从属实体</strong><strong>————————————————————————————————</strong></p><table><thead><tr><th style="text-align:center;">方法名</th><th style="text-align:center;">安全性</th><th style="text-align:center;">幂等性</th><th style="text-align:left;">请求方法的作用</th></tr></thead><tbody><tr><td style="text-align:center;">get</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:left;">请求指定的页面信息，并返回实体主体</td></tr><tr><td style="text-align:center;">head</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:left;">只请求页面的首部</td></tr><tr><td style="text-align:center;">options</td><td style="text-align:center;">√</td><td style="text-align:center;">√</td><td style="text-align:left;">允许客户端查看服务器的性能</td></tr><tr><td style="text-align:center;">delete</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:left;">请求服务器删除指定的数据</td></tr><tr><td style="text-align:center;">put</td><td style="text-align:center;">×</td><td style="text-align:center;">√</td><td style="text-align:left;">从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td style="text-align:center;">post</td><td style="text-align:center;">×</td><td style="text-align:center;">×</td><td style="text-align:left;">请求服务器接受所指定的文档作为对所标识的URI的新的从属实体</td></tr></tbody></table><p><img src="https://img2.imgtp.com/2024/05/15/P4wc3i04.png" alt="method.png"><strong>POST和GET谁更安全?</strong></p><p><strong>get更安全</strong></p><p><strong>get比post安全? --&gt;get对于服务器是安全的–&gt; get是幂等的,post是非幂等的</strong></p><p><strong>post更安全</strong></p><p><strong>① GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</strong></p><p><strong>② 浏览器有跨域访问的限制，如果是get的话，jsonp很容易突破跨域的限制。但是post跨域比较不容易。</strong></p><p>为什么put和delete是幂等，而patch则是非幂等的？ <strong>重点来了，put 和 patch 都是用于更新数据资源的。 区别 在于</strong></p><blockquote><p><strong>put 做更新操作时候是提交一整个更新后的实体（即全部），而不是需要修改的实体中的部分属性。当 URI 指向一个存在的资源，服务器要做的事就是查找并替换。</strong></p></blockquote><blockquote><p><strong>patch 做更新操作的时候是请求中的实体是一组将要应用到实体的更改（即部分），而不是像 PUT 请求那样是要替换旧资源的实体。可以理解为：PATCH 请求中的实体保存的是修改资源的指令，该指令指导服务器来对资源做出修改。</strong></p></blockquote><p><strong>怎么理解呢？要明白并理解 RESTful 核心就是 面向资源编程，如下：</strong></p><p>** PUT /flowers/1 #修改 序号为1的花（flowers） 的全部信息**</p><blockquote><p><strong>put【幂等】：用于更新资源，没有的话则执行创建操作。每次执行请求时都会先判断一下序号为1的花信息是否存在，不存在则创建，否则视为更新。很显然，请求携带的数据每次都是一样的，所以不论请求多少次，最终的结果都是后台存在这么一个资源（创建或更新）。</strong></p></blockquote><p>** PATCH /flowers/1/variety/lily/num/331 #假设url采用pathinfo模式，修改 序号为1的花（flowers） 的品种信息为百合，数量修改位431朵**</p><blockquote><p><strong>patch【非幂等】：用于更新资源，即数据实体的一部分属性，该数据必然存在，否则失去更新意义。每次执行请求时都会先判断一下序号为1的花信息是否存在，存在则更新数据信息，这里有两个属性要改，做的处理可能是这样的：品种（variety）直接改为百合（lily），而数量（num）假设原本存在100朵，我们要修改到 431 朵，所以增加 331 朵。很显然，多次请求时，会重复增加 331 ，属性数量就无法保持 431 。而 PUT 请求不论执行多少次，属性数量永远都是 431 ， PATCH 则会改变，处于不可控的地位，所以说 PUT 方法是幂等的，而 PATCH 方法不是幂等的。</strong></p></blockquote><p>** DELETE /flowers/1 #删除 序号为1的花（flowers） 的全部信息**</p><blockquote><p><strong>delete【幂等】： 用于删除资源，会将资源从后台删除。每次执行请求时都会先判断一下序号为1的花信息是否存在，存在则删除，否则不做任何操作。很显然，无论执行多少次资源的状态总是被删除的，不会有其它副作用的影响。</strong></p></blockquote><h2 id="内存泄漏问题" tabindex="-1"><a class="header-anchor" href="#内存泄漏问题"><span>内存泄漏问题？</span></a></h2>',26),y={href:"https://zhuanlan.zhihu.com/p/411103328",target:"_blank",rel:"noopener noreferrer"},b={href:"https://juejin.cn/post/7065705130963763231",target:"_blank",rel:"noopener noreferrer"},f={href:"https://juejin.cn/post/7232127712642547770",target:"_blank",rel:"noopener noreferrer"},_=o('<h2 id="前端开发中-使用base64图片的弊端是什么" tabindex="-1"><a class="header-anchor" href="#前端开发中-使用base64图片的弊端是什么"><span>前端开发中，使用base64图片的弊端是什么？</span></a></h2><ol><li>造成网页阻塞 弊端主要不在于 base64 编码后比原图要大，而是因为如果把大图片编码到 html / css 中，会造成后者体积明显增加，明显影响网页的打开速度。如果用外链图片的话，图片可以在页面渲染完成后继续加载，不会造成阻塞。如果 base64 是被编码到 css/js 中，是可以缓存的，因为 css/js 文件可以缓存。 假设base64编码后的字符串长度为256kb，用户的网速为每个连接32kb/s，而除去这个字符串外html大小仅为32kb，其中图片前后各16kb 那么不考虑其他资源加载的情况下，用户会先在半秒后看到这个图片上面的内容，然后花费8秒加载图片，再在半秒后看到完整的网页</li><li>有兼容性问题 使用 base64 的另外一个弊端是 IE 的兼容性问题。IE 8 以下不支持 data url，IE 8 开始支持 data url，却有大小限制，32k（未测试）。</li><li>用法上面的问题 还有一个问题是，如果构建工具比较落后（或者没有构建工具），手动插入 base64 是很蛋疼的，编辑器会卡到哭。</li></ol><h2 id="什么是gzip" tabindex="-1"><a class="header-anchor" href="#什么是gzip"><span>什么是Gzip？</span></a></h2><p>gzip是一种数据的压缩格式，或者说是一种文件格式。</p><blockquote><p>Gzip原本用户UNIX系统的文件压缩，后来逐渐成为Internet最主流的数据压缩格式。当用户访问我们的web站点时，服务器就将我们的网页文件进行压缩，将压缩后的文件传输到客户端，对于纯文本文件我们可以至少压缩到原大小的40%，这样大大提高了传输效率，页面便可更快的加载出来。</p></blockquote><p>gzip是一种数据的压缩格式，也可以说是文件格式。linux系统该文件后缀为.gz 。使用gzip需要web容器，浏览器的支持。</p><ul><li>配置 js、text、json、css 这种纯文本进行压缩，效率极高</li><li>压缩需要消化CPU，对于大文件（音乐/视频/图片）的压缩，会增加服务器压力。</li></ul>',7);function k(m,v){const e=s("ExternalLinkIcon");return p(),a("div",null,[g,t("p",null,[t("a",d,[r("面试官: 实现双向绑定Proxy比defineproperty优劣如何? - 掘金"),n(e)])]),c,t("p",null,[t("a",h,[r("vue的双向绑定原理与实现 - 掘金"),n(e)])]),t("p",null,[t("a",u,[r("安全验证 - 知乎"),n(e)])]),x,t("p",null,[t("a",y,[r("一文帮你解决前端开发中的内存泄露问题"),n(e)])]),t("p",null,[t("a",b,[r("前端常见内存泄漏及解决方案 - 掘金"),n(e)])]),t("p",null,[t("a",f,[r("如何查找和解决前端内存泄漏问题？ - 排查和分析技巧详解 - 掘金"),n(e)])]),_])}const P=l(i,[["render",k],["__file","other.html.vue"]]),j=JSON.parse('{"path":"/interview/other.html","title":"其他的一些小问题","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"proxy的优缺点？","slug":"proxy的优缺点","link":"#proxy的优缺点","children":[]},{"level":2,"title":"Vue的双向绑定原理（腾讯）","slug":"vue的双向绑定原理-腾讯","link":"#vue的双向绑定原理-腾讯","children":[]},{"level":2,"title":"HTTP请求方法：幂等和非幂等？","slug":"http请求方法-幂等和非幂等","link":"#http请求方法-幂等和非幂等","children":[]},{"level":2,"title":"内存泄漏问题？","slug":"内存泄漏问题","link":"#内存泄漏问题","children":[]},{"level":2,"title":"前端开发中，使用base64图片的弊端是什么？","slug":"前端开发中-使用base64图片的弊端是什么","link":"#前端开发中-使用base64图片的弊端是什么","children":[]},{"level":2,"title":"什么是Gzip？","slug":"什么是gzip","link":"#什么是gzip","children":[]}],"filePathRelative":"interview/other.md","git":{"createdTime":1715780535000,"updatedTime":1715941349000,"contributors":[{"name":"xiaoyu","email":"luoyu2003@outlook.com","commits":2}]},"readingTime":{"minutes":9.28,"words":2783}}');export{P as comp,j as data};
